'use client';

import { useEffect, useMemo, useRef, useState } from 'react';
import { TrackType } from '../mixer/assets';
import { createAudioEngine, type AudioEngine } from '../mixer/audio/audioengine';

type MixTrack = {
  id: string;
  libraryId: string; // folder name
  name: string;
  type: TrackType;
  assetId: string;
  volume: number; // 0..1

  // event-only (kept for compatibility)
  ratePreset?: 'Rare' | 'Medium' | 'Often' | 'Very Often';
  rateSpeed?: 0.5 | 1 | 2;
  randomizeVariants?: boolean;
};

type Mood = 'Sleep' | 'Focus' | 'Cozy' | 'Nature';

const EXPORT_TEMPORARILY_UNLOCKED = true;

// ---- tiny utils ----
function clamp01(v: number) {
  if (Number.isNaN(v)) return 0;
  return Math.max(0, Math.min(1, v));
}

function makeId(prefix: string) {
  return `${prefix}_${Math.random().toString(16).slice(2)}_${Date.now().toString(16)}`;
}

// deterministic RNG
function fnv1a32(str: string) {
  let h = 0x811c9dc5;
  for (let i = 0; i < str.length; i++) {
    h ^= str.charCodeAt(i);
    h = Math.imul(h, 0x01000193);
  }
  return h >>> 0;
}

function mulberry32(seed: number) {
  let a = seed >>> 0;
  return function rand() {
    a |= 0;
    a = (a + 0x6d2b79f5) | 0;
    let t = Math.imul(a ^ (a >>> 15), 1 | a);
    t = (t + Math.imul(t ^ (t >>> 7), 61 | t)) ^ t;
    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
  };
}

function pickOne<T>(rand: () => number, arr: T[]) {
  return arr[Math.floor(rand() * arr.length)];
}

function chance(rand: () => number, p: number) {
  return rand() < p;
}

async function headOk(url: string) {
  try {
    const res = await fetch(url, { method: 'HEAD' });
    return res.ok;
  } catch {
    return false;
  }
}

// ---- URL rules (locked) ----
function assetUrlFor(track: { type: TrackType; libraryId: string }, assetId: string) {
  const base = track.type === 'loop' ? 'loops' : 'events';
  return `/assets/${base}/${track.libraryId}/${assetId}.mp3`;
}

// ---- WAV export helpers ----
async function fetchAudioBuffer(ctx: BaseAudioContext, url: string) {
  const res = await fetch(url);
  if (!res.ok) throw new Error(`Failed to fetch: ${url}`);
  const arr = await res.arrayBuffer();
  return await ctx.decodeAudioData(arr);
}

function downloadBlob(blob: Blob, filename: string) {
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  a.remove();
  setTimeout(() => URL.revokeObjectURL(url), 1000);
}
function buildCertificateText(opts: {
  jobId: string;
  seed: string;
  durationMin: number;
  createdAtIso: string;
  tracks: MixTrack[];
  mood?: string; // optional (autopilot)
}) {

  const { jobId, seed, durationMin, createdAtIso, mood, tracks } = opts;

  const lines = [
    "SOUNDSCAPE EXPORT LICENSE CERTIFICATE",
    "soundscape.run",
    "",
    `Certificate ID: ${jobId}`,
    `Issued (UTC): ${createdAtIso}`,
    "",
    "LICENSE GRANT",
    "Soundscape grants a non-exclusive, perpetual, worldwide license",
    "to use the exported audio for commercial and non-commercial purposes,",
    "including videos, games, applications, podcasts, and client work.",
    "Attribution is not required.",
    "",
    "IMPORTANT RESTRICTIONS",
    "- Exported audio may not be resold or redistributed as a standalone sound library.",
    "- Exported audio may not be sublicensed on a standalone basis.",
    "- Exported audio may not be registered with YouTube Content ID",
    "  or any other fingerprinting or rights-management system.",
    "- No ownership or exclusivity may be claimed.",
    "",
    "DETERMINISTIC OUTPUT NOTICE",
    "Soundscape uses deterministic systems.",
    "Similar or identical exports may be generated by different users.",
    "No exclusivity is granted.",
    "",
    ...(mood ? [`Mood: ${mood}`] : []),

    `Seed: ${seed}`,
    `Duration: ${durationMin} minutes`,
    "",
    "Tracks:",
    ...tracks.map((t) => {
      const vol = `${Math.round(t.volume * 100)}%`;
      return `- ${t.name} (${t.type}) â€¢ ${t.libraryId}/${t.assetId}.mp3 â€¢ vol ${vol}`;
    }),
    "",
    "This certificate is issued subject to the Soundscape Terms & Conditions",
    "available at soundscape.run.",
    "",
    "Governing Law: Netherlands",
    "",
    "Â© 2026 Soundscape. All rights reserved.",
  ];

  return lines.join("\r\n");
}

function wavHeader16({
  numChannels,
  sampleRate,
  numFrames,
}: {
  numChannels: number;
  sampleRate: number;
  numFrames: number;
}) {
  const bytesPerSample = 2;
  const blockAlign = numChannels * bytesPerSample;
  const byteRate = sampleRate * blockAlign;
  const dataSize = numFrames * blockAlign;

  const buffer = new ArrayBuffer(44);
  const view = new DataView(buffer);

  const writeString = (offset: number, str: string) => {
    for (let i = 0; i < str.length; i++) view.setUint8(offset + i, str.charCodeAt(i));
  };

  writeString(0, 'RIFF');
  view.setUint32(4, 36 + dataSize, true);
  writeString(8, 'WAVE');

  writeString(12, 'fmt ');
  view.setUint32(16, 16, true); // PCM
  view.setUint16(20, 1, true); // PCM
  view.setUint16(22, numChannels, true);
  view.setUint32(24, sampleRate, true);
  view.setUint32(28, byteRate, true);
  view.setUint16(32, blockAlign, true);
  view.setUint16(34, 16, true); // 16-bit

  writeString(36, 'data');
  view.setUint32(40, dataSize, true);

  return buffer;
}

function audioBufferToPcm16LE(ab: AudioBuffer) {
  const numChannels = ab.numberOfChannels;
  const length = ab.length;

  const out = new ArrayBuffer(length * numChannels * 2);
  const view = new DataView(out);

  const chans: Float32Array[] = [];
  for (let c = 0; c < numChannels; c++) chans.push(ab.getChannelData(c));

  let offset = 0;
  for (let i = 0; i < length; i++) {
    for (let c = 0; c < numChannels; c++) {
      let s = chans[c][i];
      s = Math.max(-1, Math.min(1, s));
      const int16 = s < 0 ? s * 0x8000 : s * 0x7fff;
      view.setInt16(offset, int16, true);
      offset += 2;
    }
  }
  return out;
}

type WavInfoTags = Partial<{
  INAM: string; // Title
  IART: string; // Artist
  IPRD: string; // Product
  ICMT: string; // Comment
  ICRD: string; // Date
  ISFT: string; // Software
}>;

function u32le(n: number) {
  const b = new ArrayBuffer(4);
  new DataView(b).setUint32(0, n, true);
  return new Uint8Array(b);
}

function fourcc(s: string) {
  return new TextEncoder().encode(s);
}

function pad2(len: number) {
  return len % 2 === 1 ? 1 : 0;
}

function concatU8(chunks: Uint8Array[]) {
  const total = chunks.reduce((s, c) => s + c.length, 0);
  const out = new Uint8Array(total);
  let off = 0;
  for (const c of chunks) {
    out.set(c, off);
    off += c.length;
  }
  return out;
}

function makeListInfoChunk(info: WavInfoTags) {
  const enc = new TextEncoder();

  const subChunks: Uint8Array[] = [];
  const entries = Object.entries(info).filter(([, v]) => typeof v === "string" && v.length > 0);

  for (const [tag, value] of entries) {
    const payload = enc.encode(value);
    // each subchunk: TAG(4) + size(4) + payload + pad
    subChunks.push(
      fourcc(tag),
      u32le(payload.length),
      payload,
      new Uint8Array(pad2(payload.length))
    );
  }

  // LIST payload = "INFO" + subchunks
  const payload = concatU8([fourcc("INFO"), ...subChunks]);

  // LIST chunk = "LIST" + size + payload (+ pad on payload size)
  const size = payload.length;
  return concatU8([
    fourcc("LIST"),
    u32le(size),
    payload,
    new Uint8Array(pad2(size)),
  ]);
}

function makeWavBlobPCM16(opts: {
  pcmBytes: Uint8Array; // interleaved PCM16 LE
  sampleRate: number;
  numChannels: number;
  info?: WavInfoTags;
}) {
  const { pcmBytes, sampleRate, numChannels, info } = opts;

  const bytesPerSample = 2;
  const blockAlign = numChannels * bytesPerSample;
  const byteRate = sampleRate * blockAlign;
  const dataSize = pcmBytes.length;

  const fmtPayload = new Uint8Array(16);
  const fmtView = new DataView(fmtPayload.buffer);
  fmtView.setUint16(0, 1, true); // PCM
  fmtView.setUint16(2, numChannels, true);
  fmtView.setUint32(4, sampleRate, true);
  fmtView.setUint32(8, byteRate, true);
  fmtView.setUint16(12, blockAlign, true);
  fmtView.setUint16(14, 16, true); // bits

  const fmtChunk = concatU8([
    fourcc("fmt "),
    u32le(16),
    fmtPayload,
    new Uint8Array(pad2(16)),
  ]);

  const listChunk = info ? makeListInfoChunk(info) : new Uint8Array(0);

  const dataChunk = concatU8([
    fourcc("data"),
    u32le(dataSize),
    pcmBytes,
    new Uint8Array(pad2(dataSize)),
  ]);

  // RIFF size = 4 ("WAVE") + all subchunks
  const riffSize = 4 + fmtChunk.length + listChunk.length + dataChunk.length;

  const header = concatU8([
    fourcc("RIFF"),
    u32le(riffSize),
    fourcc("WAVE"),
  ]);

  const wav = concatU8([header, fmtChunk, listChunk, dataChunk]);
  return new Blob([wav], { type: "audio/wav" });
}


export default function AutopilotPage() {
  const audioRef = useRef<AudioEngine | null>(null);

  const [audioOn, setAudioOn] = useState(false);
  const [masterVol, setMasterVol] = useState(0.8);

  const [mood, setMood] = useState<Mood>('Focus');
  const [seed, setSeed] = useState<string>(() => `${Date.now()}`);

  const [tracks, setTracks] = useState<MixTrack[]>([]);
  const [trackStatus, setTrackStatus] = useState<Record<string, boolean>>({});

  // credits (server)
  const [credits, setCredits] = useState<number | null>(null);
  const [creditsMsg, setCreditsMsg] = useState<string>('');

  // export control plane
  const [exportDurationMin, setExportDurationMin] = useState<5 | 15 | 30 | 60>(5);
  const [isExporting, setIsExporting] = useState(false);
  const [exportMsg, setExportMsg] = useState('');
  const [exportStage, setExportStage] = useState<
    'idle' | 'starting' | 'loading' | 'rendering' | 'encoding' | 'downloading' | 'done' | 'error'
  >('idle');
  const [exportProgress, setExportProgress] = useState(0); // 0..1

  async function refreshCredits() {
    try {
      setCreditsMsg('');
      const res = await fetch('/api/credits', { cache: 'no-store' });
      // if backend returns HTML (wrong method/route), this will throw -> we handle below
      const text = await res.text();
let json: any = {};
try {
  json = text ? JSON.parse(text) : {};
} catch {
  // keep json as {}
}
if (!res.ok) throw new Error(json?.error ?? text ?? 'Failed to load credits');

      setCredits(Number(json.credits));
    } catch (e: any) {
      setCredits(null);
      setCreditsMsg(e?.message ?? 'Credits unavailable');
    }
  }

  useEffect(() => {
    refreshCredits();
  }, []);

  // cleanup
  useEffect(() => {
    return () => {
      audioRef.current?.stopAll();
    };
  }, []);

  async function activateAudio() {
    if (!audioRef.current) audioRef.current = createAudioEngine();
    await audioRef.current.activate();
    audioRef.current.setMaster(masterVol);
    setAudioOn(true);
    if (tracks.length > 0) {
      await audioRef.current.syncMix(tracks, assetUrlFor);
    }
  }

  async function toggleAudio() {
    if (audioOn) {
      audioRef.current?.stopAll();
      setAudioOn(false);
    } else {
      await activateAudio();
    }
  }

  useEffect(() => {
    if (!audioOn) return;
    if (!audioRef.current?.isActive()) return;
    audioRef.current.syncMix(tracks, assetUrlFor);
  }, [audioOn, tracks]);

  useEffect(() => {
    if (!audioOn) return;
    audioRef.current?.setMaster(masterVol);
  }, [audioOn, masterVol]);

  // HEAD status for UI confidence
  useEffect(() => {
    let alive = true;
    async function check() {
      const entries = await Promise.all(
        tracks.map(async (t) => {
          const ok = await headOk(assetUrlFor(t, t.assetId));
          return [t.id, ok] as const;
        })
      );
      if (!alive) return;
      const next: Record<string, boolean> = {};
      for (const [id, ok] of entries) next[id] = ok;
      setTrackStatus(next);
    }
    check();
    return () => {
      alive = false;
    };
  }, [tracks]);

  function makeNewSeed() {
    return `${Date.now()}_${Math.floor(Math.random() * 1e9)}`;
  }

  async function generate(seedOverride?: string) {
    const chosen = seedOverride ?? makeNewSeed();
    setSeed(chosen);

    const s = String(chosen).trim() || `${Date.now()}`;
    const rand = mulberry32(fnv1a32(`${mood}|${exportDurationMin}|${s}`));

    const beds = ['rain', 'water', 'wind', 'fireplace', 'sea', 'forest'] as const;
    const FIREPLACE_VARIANTS = ['fireplace_cozy_loop_01', 'fireplace_cozy_open_01'] as const;

    const includeSecondBed = chance(rand, mood === 'Cozy' ? 0.35 : 0.55);

    let primaryBed: (typeof beds)[number];
    if (mood === 'Cozy') primaryBed = 'fireplace';
    else if (mood === 'Focus') primaryBed = pickOne(rand, ['rain', 'water'] as const);
    else if (mood === 'Sleep') primaryBed = pickOne(rand, ['rain', 'wind'] as const);
    else primaryBed = pickOne(rand, ['water', 'wind', 'rain'] as const);

    let secondaryBed: (typeof beds)[number] | null = null;
    if (includeSecondBed) {
      const options = beds.filter((b) => b !== primaryBed);
      secondaryBed =
        mood === 'Sleep'
          ? (pickOne(rand, options.filter((b) => b !== 'fireplace')) || null)
          : (pickOne(rand, options) || null);
    }

    const next: MixTrack[] = [];

    async function addLoop(libraryId: string, assetId: string, volume: number) {
      const url = assetUrlFor({ type: 'loop', libraryId }, assetId);
      if (!(await headOk(url))) return false;

      next.push({
        id: makeId('t'),
        libraryId,
        name:
          libraryId === 'rain'
            ? 'Rain'
            : libraryId === 'wind'
              ? 'Dunes Wind'
              : libraryId === 'water'
                ? 'Water Stream'
                : libraryId === 'fireplace'
                  ? 'Fireplace'
                  : libraryId === 'sea'
                    ? 'Sea'
                    : libraryId === 'forest'
                      ? 'Forest'
                      : libraryId,
        type: 'loop',
        assetId,
        volume: clamp01(volume),
      });
      return true;
    }

    const base = mood === 'Sleep' ? 0.42 : mood === 'Cozy' ? 0.55 : 0.5;

    // primary bed
    if (primaryBed === 'rain') {
      await addLoop('rain', 'rain_soft_loop_01', base);
    } else if (primaryBed === 'water') {
      await addLoop('water', 'water_stream_with_distant_birds_01', base);
    } else if (primaryBed === 'wind') {
      await addLoop('wind', 'dunes_wind', base);
    } else if (primaryBed === 'fireplace') {
      const fireplaceAsset = pickOne(rand, [...FIREPLACE_VARIANTS]);
      await addLoop('fireplace', fireplaceAsset, mood === 'Sleep' ? 0.38 : 0.58);
    } else if (primaryBed === 'sea') {
      await addLoop('sea', 'sea_loop_01', base);
    } else {
      await addLoop('forest', 'Forest_birds_01', base);
    }

    // secondary bed
    if (secondaryBed) {
      if (secondaryBed === 'rain') {
        await addLoop('rain', 'rain_soft_loop_01', base * 0.65);
      } else if (secondaryBed === 'water') {
        await addLoop('water', 'water_stream_with_distant_birds_01', base * 0.65);
      } else if (secondaryBed === 'wind') {
        await addLoop('wind', 'dunes_wind', base * 0.65);
      } else if (secondaryBed === 'fireplace') {
        const fireplaceAsset = pickOne(rand, [...FIREPLACE_VARIANTS]);
        await addLoop('fireplace', fireplaceAsset, base * 0.5);
      } else if (secondaryBed === 'sea') {
        await addLoop('sea', 'sea_loop_01', base * 0.65);
      } else {
        await addLoop('forest', 'Forest_birds_01', base * 0.65);
      }
    }

    setTracks(next);

    if (audioOn && audioRef.current?.isActive()) {
      audioRef.current.syncMix(next, assetUrlFor);
    }
  }

  function buildRecipeTextFor(seedValue: string) {
    const s = String(seedValue).trim() || `${Date.now()}`;
    const lines = [
      `Mood=${mood} â€¢ Length=${exportDurationMin}m â€¢ Seed=${s}`,
      ...tracks.map((t) => {
        const vol = `${Math.round(t.volume * 100)}%`;
        return `- ${t.name} (${t.type}) â€¢ ${t.libraryId}/${t.assetId}.mp3 â€¢ vol ${vol}`;
      }),
    ];
    return lines.join('\r\n');
  }

async function onExportWavAndRecipe() {
  if (exportDurationMin >= 60) {
    const ok = confirm('60 min WAV is ~600MB and may crash the browser tab on some machines. Continue?');
    if (!ok) return;
  }

  let jobId: string | null = null;

  if (!EXPORT_TEMPORARILY_UNLOCKED) return;
  if (isExporting) return;
  if (tracks.length === 0) return alert('Generate a mix first.');

  const seedForExport = String(seed).trim() || `${Date.now()}`;

  const chunkSec = 60;
  const totalSec = exportDurationMin * 60;
  const chunks = Math.ceil(totalSec / chunkSec);

  const sampleRate = 44100;
  const numChannels = 2;

  setExportMsg('');
  setIsExporting(true);
  setExportStage('starting');
  setExportProgress(0.02);

  try {
    // IMPORTANT: idempotency key prevents double-charge on retries/double-clicks
    const idempotencyKey =
      globalThis.crypto?.randomUUID?.() ?? `${Date.now()}_${Math.random()}`;

    type ExportStartOk = { jobId: string; creditsCost?: number };
    type ExportStartErr = { error?: string };
    const startRes = await fetch('/api/export/start', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      cache: 'no-store',
      body: JSON.stringify({
        durationMin: exportDurationMin,
        seed: seedForExport,
        idempotencyKey,
      }),
    });

    const startJson = (await startRes.json().catch(() => ({}))) as ExportStartOk & ExportStartErr;

    if (!startRes.ok) {
      setExportStage('error');
      setExportMsg(startJson?.error ?? 'Could not start export');
      return;
    }

    jobId = typeof startJson.jobId === 'string' ? startJson.jobId : null;

    if (!jobId) {
      setExportStage('error');
      setExportMsg('Could not start export (missing jobId).');
      return;
    }
const createdAtIso = new Date().toISOString();

const info: WavInfoTags = {
  INAM: "Soundscape Export",
  IART: "Soundscape",
  IPRD: "Soundscape Web",
  ISFT: "Soundscape Web",
  ICRD: createdAtIso,
  ICMT: [
    "SOUNDSCAPE EXPORT LICENSE",
    "soundscape.run",
    "",
    `Certificate ID: ${jobId}`,
    `Issued (UTC): ${createdAtIso}`,
    "",
    "License: non-exclusive, perpetual, worldwide (commercial & non-commercial).",
    "Restrictions: no resell as library â€¢ no sublicensing standalone â€¢ no Content ID.",
    "Deterministic: similar/identical exports may occur â€¢ no exclusivity.",
    "",
    `Mood: ${mood}`,
    `Seed: ${seedForExport}`,
    `Duration: ${exportDurationMin} minutes`,

    "",
    "Governing Law: Netherlands",
  ].join("\r\n"),
};



    setExportStage('loading');
    setExportProgress(0.08);

    // Decode buffers once
    const decodeCtx = new OfflineAudioContext(1, 1, sampleRate);
    const urls = Array.from(new Set(tracks.map((t) => assetUrlFor(t, t.assetId))));
    const buffers = new Map<string, AudioBuffer>();

    await Promise.all(
      urls.map(async (u) => {
        try {
          buffers.set(u, await fetchAudioBuffer(decodeCtx, u));
        } catch {
          console.warn('Missing audio for export:', u);
        }
      })
    );

    setExportStage('rendering');

    const pcmParts: ArrayBuffer[] = [];
    const totalFrames = Math.floor(totalSec * sampleRate);
    const LOOP_PAD = 0.02;

    for (let i = 0; i < chunks; i++) {
      const chunkStart = i * chunkSec;
      const chunkLenSec = Math.min(chunkSec, totalSec - chunkStart);
      const chunkFrames = Math.floor(chunkLenSec * sampleRate);

      const off = new OfflineAudioContext(numChannels, chunkFrames, sampleRate);

      const master = off.createGain();
      master.gain.value = clamp01(masterVol);
      master.connect(off.destination);

      for (const t of tracks.filter((x) => x.type === 'loop')) {
        const u = assetUrlFor(t, t.assetId);
        const buf = buffers.get(u);
        if (!buf) continue;

        const src = off.createBufferSource();
        src.buffer = buf;
        src.loop = true;

        const loopStart = LOOP_PAD;
        const loopEnd = Math.max(LOOP_PAD, buf.duration - LOOP_PAD);
        src.loopStart = loopStart;
        src.loopEnd = loopEnd;

        const loopSpan = Math.max(0.001, loopEnd - loopStart);
        const rel = chunkStart % loopSpan;
        const offset = loopStart + rel;

        const g = off.createGain();
        g.gain.value = clamp01(t.volume);

        src.connect(g);
        g.connect(master);

        src.start(0, offset);
      }

      const renderedChunk = await off.startRendering();

      const p = (i + 1) / chunks;
      setExportProgress(0.10 + p * 0.75);

      pcmParts.push(audioBufferToPcm16LE(renderedChunk));
    }

setExportStage('encoding');
setExportProgress(0.88);

// Build WAV with LIST/INFO metadata
const pcmBytes = concatU8(pcmParts.map((ab) => new Uint8Array(ab)));
const wavBlob = makeWavBlobPCM16({ pcmBytes, sampleRate, numChannels, info });

setExportStage('downloading');
setExportProgress(0.95);

const baseName = `soundscape_${mood.toLowerCase()}_${exportDurationMin}m_${seedForExport}`;
downloadBlob(wavBlob, `${baseName}.wav`);


// Certificate (separate .txt file)
const certText = buildCertificateText({
  jobId,
  seed: seedForExport,
  durationMin: exportDurationMin,
  createdAtIso,
  mood,
  tracks,
});

downloadBlob(new Blob([certText], { type: 'text/plain' }), `${baseName}_certificate.txt`);



    const recipeText = buildRecipeTextFor(seedForExport);
    downloadBlob(new Blob([recipeText], { type: 'text/plain' }), `${baseName}_recipe.txt`);

    setExportStage('done');
    setExportProgress(1);
    setExportMsg('Downloaded WAV + certificate + recipe.');

    // complete (idempotent server-side)
    await fetch('/api/export/complete', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      cache: 'no-store',
      body: JSON.stringify({ jobId }),
    });

    // refresh credits after successful export
    await refreshCredits();
  } catch (e) {
    console.error(e);

    // rollback reservation if something failed
    if (jobId) {
      await fetch('/api/export/cancel', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        cache: 'no-store',
        body: JSON.stringify({ jobId }),
      }).catch(() => {});
    }

    setExportStage('error');
    setExportMsg('Export failed. Check console.');
  } finally {
    setIsExporting(false);
  }
}


  const nowPlaying = useMemo(() => {
    if (tracks.length === 0) return 'Generate a mix to start.';
    return `${tracks.length} track(s) loaded.`;
  }, [tracks]);

  return (
    <main className="mx-auto max-w-4xl p-6">
      <div className="glass-panel elev-3 rounded-3xl p-6">
        {/* Header */}
        <div className="flex items-start justify-between gap-4">
          <div>
            <h1 className="text-xl font-semibold">Autopilot</h1>
            <p className="mt-1 text-sm text-faint">
              Deterministic mix generator using only available assets. No AI.
            </p>
          </div>

          <div className="flex flex-col items-end gap-2">
            <div className="flex items-center gap-2">
              <div className="glass-panel rounded-xl px-3 py-2 text-xs text-faint">
                Credits:{' '}
                <span className="text-app">{credits === null ? 'â€”' : credits}</span>
              </div>

              <a href="/pricing" className="btn-glass rounded-xl px-3 py-2 text-xs">
                Buy
              </a>
            </div>

            {creditsMsg && <div className="text-xs text-faint">{creditsMsg}</div>}
          </div>
        </div>

        {/* Controls */}
        <div className="mt-5 grid grid-cols-1 gap-4 md:grid-cols-[1fr_auto] md:items-end">
          <div>
            <label className="text-xs text-faint">Mood</label>
            <select
              className="glass-panel mt-1 w-full rounded-lg px-2 py-2 text-sm"
              value={mood}
              onChange={(e) => setMood(e.target.value as Mood)}
            >
              <option>Sleep</option>
              <option>Focus</option>
              <option>Cozy</option>
              <option>Nature</option>
            </select>
          </div>

          <div className="flex gap-2 md:justify-end">
            <button onClick={() => generate()} className="btn-glass rounded-xl px-4 py-2 text-sm">
              Generate
            </button>
            <button onClick={toggleAudio} className="btn-glass rounded-xl px-4 py-2 text-sm">
              {audioOn ? 'Stop' : 'Play'}
            </button>
          </div>
        </div>

        {/* Now Playing */}
        <div className="glass-panel mt-5 rounded-3xl p-6">
          <div className="flex items-center justify-between">
            <div className="font-medium">Now Playing</div>
            <div className="flex items-center gap-3">
              <span className="text-xs text-faint">Master</span>
              <input
                type="range"
                className="w-40"
                min={0}
                max={1}
                step={0.01}
                value={masterVol}
                onChange={(e) => setMasterVol(Number(e.target.value))}
              />
            </div>
          </div>

          <div className="mt-3 text-sm text-faint">{nowPlaying}</div>

          {tracks.length > 0 && (
            <div className="mt-3 space-y-2">
              {tracks.map((t) => (
                <div key={t.id} className="glass-panel flex items-center justify-between rounded-lg px-3 py-2">
                  <div className="min-w-0">
                    <div className="flex items-center gap-2">
                      <div className="font-medium">{t.name}</div>
                      <span className="text-xs text-faint">({t.type})</span>
                      <span className="text-xs">{trackStatus[t.id] ? 'ðŸŸ¢' : 'ðŸ”´'}</span>
                    </div>
                    <div className="mt-1 text-xs text-faint truncate">{assetUrlFor(t, t.assetId)}</div>
                  </div>

                  <div className="flex items-center gap-3">
                    <div className="w-10 text-right text-xs text-faint">{Math.round(t.volume * 100)}%</div>
                    <input
                      type="range"
                      className="w-36"
                      min={0}
                      max={1}
                      step={0.01}
                      value={t.volume}
                      onChange={(e) => {
                        const v = Number(e.target.value);
                        setTracks((prev) => prev.map((x) => (x.id === t.id ? { ...x, volume: v } : x)));
                      }}
                    />
                  </div>
                </div>
              ))}
            </div>
          )}
        </div>

        {/* Export */}
        <div className="glass-panel mt-5 rounded-3xl p-6">
          <h2 className="text-lg font-semibold">Export</h2>
          <p className="mt-1 text-sm text-faint">

          </p>

          <div className="mt-4 space-y-3">
            <select
              className="glass-surface mt-1 w-full rounded-lg px-3 py-2 text-sm text-app focus:outline-none focus:ring-2 focus:ring-white/20"
              value={exportDurationMin}
              onChange={(e) => setExportDurationMin(Number(e.target.value) as 5 | 15 | 30 | 60)}
            >
              <option value={5} className="text-app">5 min</option>
              <option value={15} className="text-app">15 min</option>
              <option value={30} className="text-app">30 min</option>
              <option value={60} className="text-app">60 min</option>
            </select>

            <button
              className={`glass-panel w-full rounded-lg border px-4 py-2 text-sm ${
                EXPORT_TEMPORARILY_UNLOCKED ? 'hover:glass-inset' : 'text-faint'
              }`}
              disabled={!EXPORT_TEMPORARILY_UNLOCKED || isExporting}
              onClick={onExportWavAndRecipe}
            >
              {isExporting ? 'Exportingâ€¦' : 'Export WAV + Recipe'}
            </button>

            {(isExporting || exportStage === 'done' || exportStage === 'error') && (
              <div className="mt-3">
                <div className="flex items-center justify-between text-xs text-faint">
                  <span>
                    {exportStage === 'starting' && 'Startingâ€¦'}
                    {exportStage === 'loading' && 'Loading audioâ€¦'}
                    {exportStage === 'rendering' && 'Renderingâ€¦'}
                    {exportStage === 'encoding' && 'Encoding WAVâ€¦'}
                    {exportStage === 'downloading' && 'Downloadingâ€¦'}
                    {exportStage === 'done' && 'Done.'}
                    {exportStage === 'error' && 'Export failed.'}
                  </span>
                  <span>{Math.round(exportProgress * 100)}%</span>
                </div>

                <div className="mt-2 h-2 w-full rounded-full bg-white/10">
                  <div
                    className="h-2 rounded-full bg-white/30 transition-[width] duration-200"
                    style={{ width: `${Math.round(exportProgress * 100)}%` }}
                  />
                </div>
              </div>
            )}

            {exportMsg && <div className="text-xs text-faint">{exportMsg}</div>}

<div className="glass-panel mt-5 rounded-3xl p-6 text-xs text-faint">
  <div className="font-medium">Export includes:</div>
  <ul className="mt-2 list-disc space-y-1 pl-4">
    <li>Deterministic WAV export (44.1kHz / 16-bit)</li>
    <li>Seeded reproducibility</li>
    <li>License certificate (.txt)</li>
    <li>Recipe file for regeneration</li>
  </ul>
</div>

          </div>
        </div>


      </div>
    </main>
  );
}
